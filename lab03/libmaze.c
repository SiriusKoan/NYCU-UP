#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <stdbool.h>
#include <sys/mman.h>
#include <stdint.h>

#include "libmaze.h"

static void * __stored_ptr = NULL;
// 0: up, 1: down, 2: left, 3: right
int directions[1200] = {0};
// void* original_move_addr[1200] = {0};
int original_move_addr[1199] = {144648, 141000, 142264, 138464, 139624, 145800, 146968, 143392, 144600, 145248, 144048, 142880, 141664, 140176, 139160, 138008, 146464, 145296, 144088, 146752, 145360, 144360, 143168, 141976, 140744, 139432, 138320, 146768, 145392, 143416, 142240, 140792, 139696, 138552, 147016, 145848, 144616, 143448, 142256, 142576, 141320, 140048, 138872, 147296, 146128, 144864, 143664, 142528, 141240, 146456, 145280, 144112, 142912, 141680, 140328, 139096, 137968, 146392, 145240, 145528, 144376, 143176, 141960, 140720, 139464, 138296, 146744, 145512, 144312, 139720, 138560, 147008, 145824, 144640, 143424, 142232, 140944, 139648, 138520, 146120, 144856, 143656, 142520, 141232, 140008, 138832, 147272, 146112, 144696, 142904, 141672, 140320, 139088, 137960, 146384, 145232, 144040, 142872, 141656, 141744, 140416, 139208, 138056, 146504, 145040, 143848, 142696, 141432, 140144, 138384, 146808, 145584, 144408, 143200, 142008, 140488, 139272, 138088, 146560, 143496, 142320, 141056, 139768, 138632, 147056, 145880, 144472, 143272, 142080, 140160, 138928, 147368, 146184, 144968, 143776, 142616, 141336, 139816, 138704, 145200, 144032, 142848, 141616, 140304, 139072, 137920, 146368, 145160, 143984, 139392, 138272, 146712, 145496, 144296, 143088, 141888, 140616, 139360, 138224, 142192, 140928, 139600, 138472, 146888, 145752, 144560, 143376, 142168, 140880, 146072, 144824, 143624, 142456, 141192, 139944, 138792, 147216, 146024, 144792, 139064, 137912, 146360, 145152, 143976, 142808, 141568, 140272, 139024, 137864, 145488, 144288, 143080, 141880, 140608, 139352, 138216, 146672, 145464, 144256, 141968, 143160, 144344, 145536, 146736, 138288, 139424, 140688, 141696, 142920, 146304, 137840, 139000, 140248, 141512, 142752, 143896, 145104, 146240, 147408, 142400, 143560, 144752, 145984, 147160, 138728, 139888, 141104, 142360, 143520, 139568, 140856, 142128, 143320, 144504, 145672, 146840, 138400, 139528, 140824, 145440, 146616, 138168, 139312, 140552, 141792, 143000, 144176, 145384, 146608, 142744, 143888, 145096, 146232, 147400, 138944, 140192, 141504, 142728, 143856, 145976, 147152, 138720, 139880, 141096, 142352, 143512, 144704, 145968, 147144, 145664, 146832, 138392, 139520, 140816, 142120, 143304, 144488, 145632, 146944, 139304, 140544, 141784, 142992, 144168, 145376, 146600, 138144, 139288, 140504, 138864, 140088, 141384, 142632, 143744, 144944, 146296, 137832, 138992, 140240, 141904, 145480, 144272, 138248, 146696, 140640, 139376, 142832, 141608, 145184, 138488, 146912, 140920, 139592, 143384, 142184, 145744, 144568, 138264, 146704, 142344, 141080, 144688, 143504, 147072, 145904, 139776, 138656, 142288, 141016, 146224, 140168, 138936, 142648, 141392, 144976, 143792, 147328, 146152, 140080, 145352, 144160, 138072, 146528, 140440, 139224, 142944, 141712, 145312, 144104, 139512, 143224, 142040, 145608, 144424, 138336, 146784, 140760, 139456, 143216, 145912, 139784, 138648, 142280, 141008, 144632, 143440, 147064, 145888, 139728, 142640, 141400, 144984, 143784, 147320, 146144, 140072, 138856, 142624, 141368, 139216, 142936, 141704, 145304, 144096, 138064, 146512, 140408, 139176, 143064, 145600, 144416, 138328, 146776, 140752, 139448, 143208, 142016, 145576, 144384, 141312, 142568, 139056, 140296, 146344, 137888, 144008, 145176, 141584, 142816, 147000, 143616, 144816, 141184, 142448, 138808, 139952, 146048, 147224, 143328, 140712, 146728, 138280, 144368, 145560, 141952, 143152, 139608, 140912, 146896, 144072, 145272, 141648, 142896, 139168, 140392, 146448, 138000, 144280, 145472, 147288, 143728, 144936, 141304, 142560, 139048, 140288, 146336, 137880, 144000, 140976, 142224, 138576, 139712, 145840, 146992, 143608, 144808, 141176, 142440, 142112, 143296, 139344, 140592, 146632, 138200, 144232, 145432, 141832, 143040, 138136, 143936, 145128, 141536, 142792, 138984, 140224, 146288, 137824, 143960, 143864, 145088, 141496, 142720, 138768, 139936, 146000, 147192, 143544, 144736, 139872, 145960, 147136, 143360, 144552, 140872, 142152, 138416, 139560, 145704, 141224, 140376, 139152, 137984, 146432, 145264, 144056, 142888, 141640, 139808, 144016, 142824, 141592, 140312, 139080, 137928, 146376, 145544, 144328, 143136, 140656, 139384, 138232, 146680, 145504, 144304, 143104, 141896, 140984, 139672, 140904, 139640, 138504, 146928, 145776, 144920, 143712, 142544, 141272, 140032, 147240, 146064, 144848, 143648, 142488, 141216, 140368, 139144, 137976, 146424, 138048, 146496, 145032, 143840, 142688, 141448, 140136, 138912, 147384, 146208, 142000, 140480, 139264, 138096, 146552, 145344, 144152, 142976, 141776, 140672, 139760, 138624, 147048, 145872, 144464, 143264, 142072, 140808, 139504, 138368, 143768, 142608, 141344, 139824, 138696, 147088, 145928, 144680, 143480, 142336, 141736, 140424, 139200, 138040, 146488, 145024, 143832, 142680, 141440, 140128, 141528, 142768, 143912, 145120, 146200, 147344, 138896, 140096, 141376, 142584, 147176, 138744, 139904, 141072, 142304, 143464, 144656, 145896, 147024, 138592, 144520, 145688, 146824, 138352, 139488, 140784, 142032, 143184, 144392, 145568, 140568, 141760, 142960, 144136, 145328, 146520, 138016, 139184, 140400, 141688, 137784, 138968, 140200, 141520, 142760, 143904, 145112, 146192, 147336, 138888, 141120, 142376, 143528, 144712, 145992, 147168, 138736, 139896, 141064, 142296, 140832, 142136, 143336, 144512, 145680, 146816, 138344, 139480, 140776, 142024, 144192, 145400, 146624, 138176, 139320, 140560, 141752, 142952, 144128, 145320, 144064, 145256, 146136, 147304, 138848, 140064, 141296, 142552, 143720, 144928, 140016, 140992, 142248, 143432, 144624, 145816, 146976, 138544, 139688, 140736, 141416, 145000, 143808, 137808, 146264, 140208, 138960, 142736, 141472, 145056, 140456, 139240, 143024, 141816, 145416, 144208, 138160, 146584, 140512, 139280, 144440, 138440, 146864, 140848, 139544, 143312, 142088, 145640, 144480, 138256, 141040, 144664, 143456, 147080, 145920, 139800, 138664, 142392, 141112, 144720, 147352, 146168, 140104, 138880, 142656, 141408, 144992, 143800, 137800, 146256, 144120, 138080, 146536, 140448, 139232, 143016, 141808, 145408, 144200, 138152, 140768, 139472, 143240, 142048, 145616, 144432, 138432, 146856, 140840, 139536, 139960, 138800, 142200, 140936, 144584, 143400, 146904, 145760, 139616, 138480, 143992, 147248, 146080, 139976, 138824, 142472, 141200, 144832, 143632, 147104, 138240, 146688, 140648, 139368, 142840, 141600, 145192, 144024, 137896, 146352, 140968, 142216, 138568, 139704, 145832, 146984, 143600, 144800, 141168, 142432, 142104, 143288, 139336, 140584, 146648, 138192, 144224, 145424, 141824, 143032, 138128, 143928, 145144, 141552, 142784, 138976, 140216, 146280, 137816, 143952, 143880, 145080, 141488, 142712, 138760, 139928, 146016, 147184, 143536, 144728, 139864, 145952, 147128, 143352, 144544, 140864, 142144, 138408, 139552, 145696, 138424, 144496, 145656, 142096, 143280, 139328, 140576, 146640, 138184, 144216, 141840, 143008, 139296, 140536, 146592, 138120, 143920, 145136, 141544, 142776, 140232, 146272, 137792, 143872, 145072, 141480, 142704, 138752, 139920, 146008, 143552, 144744, 141128, 142384, 138712, 139856, 145944, 147120, 143344, 144536, 139440, 140728, 146760, 138312, 144352, 145552, 141944, 143144, 139416, 140680, 140896, 139632, 138496, 146920, 145768, 144912, 143704, 142536, 141264, 140040, 147232, 146056, 144840, 143640, 142480, 141208, 140384, 139136, 137992, 146416, 138032, 146480, 145016, 143824, 142672, 141464, 140120, 138904, 147376, 146216, 141992, 140472, 139256, 138112, 146576, 145336, 144144, 142968, 141768, 140664, 139752, 138616, 147040, 145864, 144456, 143256, 142064, 140800, 139496, 138360, 143760, 142600, 141352, 139832, 138688, 147096, 145936, 144672, 143472, 142328, 141728, 140432, 139192, 138024, 146472, 145008, 143816, 142664, 141456, 140112, 138376, 146800, 145592, 144400, 143192, 141984, 140464, 139248, 138104, 146568, 143488, 142312, 141048, 139744, 138608, 147032, 145856, 144448, 143248, 142056, 140152, 138920, 147360, 146176, 144960, 143752, 142592, 141360, 139840, 138680, 138784, 147208, 146040, 144784, 143592, 142464, 141152, 139968, 138816, 147112, 145712, 146160, 143368, 142160, 140888, 139584, 138456, 146880, 145728, 144576, 141864, 140600, 141032, 138208, 146656, 145456, 144264, 143096, 141872, 140632, 139016, 137872, 146320, 146792, 143944, 142800, 141576, 140280, 139040, 137904, 144760, 143568, 142424, 141136, 141720, 138776, 147200, 146032, 144776, 143584, 139408, 138672, 146664, 145448, 144240, 143056, 141856, 140624, 139664, 138512, 143232, 141560, 140256, 139008, 137848, 146312, 145168, 144320, 143112, 141928, 147280, 146104, 144880, 143680, 142408, 141144, 140344, 139112, 137952, 146400, 140960, 139656, 138536, 146872, 145720, 144888, 143672, 142512, 141248, 140000, 143128, 141936, 140704, 139792, 138640, 146952, 145784, 144608, 143408, 142176, 140528, 139992, 146096, 147264, 143696, 144904, 141288, 142504, 138840, 140056, 145216, 141632, 142864, 139128, 140360, 146440, 137944, 144080, 145288, 141328, 141912, 139848, 139400, 145520, 146720, 143120, 144336, 140696, 141920, 138304, 145792, 146936, 145064, 144592, 140952, 142208, 138528, 139680, 145808, 146960, 144872, 141256, 142496, 140520, 139984, 146088, 147256, 143688, 144896, 141280, 139104, 140336, 146408, 137936, 145648, 145208, 141624, 142856, 139120, 140352, 142928, 144528, 140184, 141424, 147392, 138952, 145048, 146248, 143072, 144248, 139912, 145368, 146544, 142984, 144184, 140496, 141800, 138448, 139576, 145736, 141024, 142272, 138600, 139736, 145624, 146848, 143576, 144768, 141160, 142416, 147312, 143736, 144952, 141088, 142368, 139032, 140264, 146328, 137856, 143968};
void (*move_up_addr)(maze_t *mz);
void (*move_down_addr)(maze_t *mz);
void (*move_left_addr)(maze_t *mz);
void (*move_right_addr)(maze_t *mz);
unsigned long long got_min;
unsigned long long got_max;

bool dfs(maze_t* mz, int x, int y, int step) {
	// printf("x = %d, y = %d, ex = %d, ey = %d\n", x, y, mz->ex, mz->ey);
	if (x == mz->ex && y == mz->ey) {
		return true;
	}
	if (mz->blk[y][x] != 0) {
		return false;
	}
	// mz->blk[y][x] = step;
	if (x > 0 && mz->blk[y][x - 1] == 0) {
		directions[step] = 2;
		if (step > 0 && directions[step - 1] == 3) {}
		else if (dfs(mz, x - 1, y, step + 1)) {
			return true;
		}
	}
	if (x < mz->w && mz->blk[y][x + 1] == 0) {
		directions[step] = 3;
		if (step > 0 && directions[step - 1] == 2) {}
		else if (dfs(mz, x + 1, y, step + 1)) {
			return true;
		}
	}
	if (y > 0 && mz->blk[y - 1][x] == 0) {
		directions[step] = 0;
		if (step > 0 && directions[step - 1] == 1) {}
		else if (dfs(mz, x, y - 1, step + 1)) {
			return true;
		}
	}
	if (y < mz->h && mz->blk[y + 1][x] == 0) {
		directions[step] = 1;
		if (step > 0 && directions[step - 1] == 0) {}
		else if (dfs(mz, x, y + 1, step + 1)) {
			return true;
		}
	}
	directions[step] = -1;
	return false;
}

int
maze_init() {
	fprintf(stderr, "MAZE: library init - stored pointer = %p.\n", __stored_ptr);
	fprintf(stderr, "UP112_GOT_MAZE_CHALLENGE\n");
	for (int i = 0; i < 1200; i++) {
		directions[i] = -1;
	}
	maze_t *mz = maze_load("/maze.txt");
	dfs(mz, mz->sx, mz->sy, 1);
	void* handle = dlopen("libmaze.so", RTLD_LAZY);
	if (handle == NULL) {
		perror("dlopen");
		return -1;
	}
	// void* got_addr = dlsym(handle, "_GLOBAL_OFFSET_TABLE_");
	// char* error;
	// if ((error = dlerror()) != NULL) {
	// 	fprintf(stderr, "%s\n", error);
	// 	dlclose(handle);
	// 	return -1;
	// }
	// dlclose(handle);
	// printf("GOT @ %p\n", got_addr);
	// if (mprotect(got_addr, 0x100, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {
	// 	perror("mprotect");
	// 	return -1;
	// }
	// disable memory protect for got
	move_up_addr = dlsym(handle, "move_up");
	move_down_addr = dlsym(handle, "move_down");
	move_left_addr = dlsym(handle, "move_left");
	move_right_addr = dlsym(handle, "move_right");
	fprintf(stderr, "move_up @ %p\n", move_up_addr);
	size_t base = (size_t) maze_get_ptr() - 0x1b7a9;
	if (mprotect((void *) ((base + 0x20000) & ~(4096ULL - 1)), 4096 * 5, PROT_READ | PROT_WRITE) == -1) {
		perror("mprotect");
		return -1;
	}
	for (int i = 0; i < 1200; i++) {
		// char move_name[20];
		// snprintf(move_name, 20, "move_%d", i);
		// void (*move_func)(maze_t *mz) = dlsym(RTLD_NEXT, move_name);
		// original_move_addr[i - 1] = (void *) move_func;
		// printf("move_%d @ %p\n", i, original_move_addr[i - 1]);
		// *(size_t *) (__stored_ptr - 0x1b7a9 + original_move_addr[i - 1]) = (size_t) ;
		if (directions[i] == 0) {
			printf("U");
			// move_up(mz);
			*(size_t *) ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[i - 1]) = (size_t) move_up_addr;
		} else if (directions[i] == 1) {
			printf("D");
			// move_down(mz);
			*(size_t *) ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[i - 1]) = (size_t) move_down_addr;
		} else if (directions[i] == 2) {
			printf("L");
			// move_left(mz);
			*(size_t *) ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[i - 1]) = (size_t) move_left_addr;
		} else if (directions[i] == 3) {
			printf("R");
			// move_right(mz);
			*(size_t *) ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[i - 1]) = (size_t) move_right_addr;
		}
	}
	dlclose(handle);
	return 0;
}

void
maze_set_ptr(void *ptr) {
	__stored_ptr = ptr;
	fprintf(stderr, "SOLVER: _main = %p.\n", __stored_ptr);
}

void *
maze_get_ptr() {
	return __stored_ptr;
}

/*
maze_t *
maze_load(const char *fn) {
	maze_t *mz = NULL;
	FILE *fp = NULL;
	int i, j, k;
	//
	got_min = ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[0]);
	got_max = got_min;
	for (int i = 1; i < 1199; i++) {
		unsigned long long move_addr = ((unsigned long long)__stored_ptr - 0x1b7a9 + original_move_addr[i]);
		if (move_addr < got_min) {
			got_min = move_addr;
		} else if (move_addr > got_max) {
			got_max = move_addr;
		}
	}
	got_min = (void**) ((unsigned long long) got_min & 0xfffffffffffff000);
	got_max = (void**) ((unsigned long long) (got_max + 0xfff) & 0xfffffffffffff000);
	fprintf(stderr, "main = %p, GOT_MIN = %p, GOT_MAX = %p\n", __stored_ptr, got_min, got_max);
	if((fp = fopen(fn, "rt")) == NULL) {
		fprintf(stderr, "MAZE: fopen failed - %s.\n", strerror(errno));
		return NULL;
	}
	if((mz = (maze_t*) malloc(sizeof(maze_t))) == NULL) {
		fprintf(stderr, "MAZE: alloc failed - %s.\n", strerror(errno));
		goto err_quit;
	}
	if(fscanf(fp, "%d %d %d %d %d %d", &mz->w, &mz->h, &mz->sx, &mz->sy, &mz->ex, &mz->ey) != 6) {
		fprintf(stderr, "MAZE: load dimensions failed - %s.\n", strerror(errno));
		goto err_quit;
	}
	mz->cx = mz->sx;
	mz->cy = mz->sy;
	for(i = 0; i < mz->h; i++) {
		for(j = 0; j < mz->w; j++) {
			if(fscanf(fp, "%d", &k) != 1) {
				fprintf(stderr, "MAZE: load blk (%d, %d) failed - %s.\n", j, i, strerror(errno));
				goto err_quit;
			}
			mz->blk[i][j] = k<<20;
		}
	}
	fclose(fp);
	fprintf(stderr, "MAZE: loaded [%d, %d]: (%d, %d) -> (%d, %d)\n",
		mz->w, mz->h, mz->sx, mz->sy, mz->ex, mz->ey);
	// print maze
	for(i = 0; i < mz->h; i++) {
		for(j = 0; j < mz->w; j++) {
			if (i == mz->sy && j == mz->sx) {
				printf("S");
			} else if (i == mz->ey && j == mz->ex) {
				printf("E");
			} else if (mz->blk[i][j] == 0) {
				printf(".");
			} else {
				printf("#");
			}
		}
		printf("\n");
	}
	// solve
	dfs(mz, mz->sx, mz->sy, 1);
	if (mprotect(got_min, (char*)got_max - (char*)got_min, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {
		perror("mprotect");
		goto err_quit;
	}
	for (int i = 0; i < 2; i++) {
		// if (directions[i] == -1) {
		// 	break;
		// }
		void** move_addr = (void**) ((unsigned long long) __stored_ptr - 0x1b7a9 + original_move_addr[i]);
		// fprintf(stderr, "move_%d @ %p\n", i + 1, move_addr);
		// void** lower = (int) move_addr & 0xfffffffffffff000;
		// void** upper = (int) (move_addr + 0xfff) & 0xfffffffffffff000;
		// if (mprotect(lower, (char*)upper - (char*)lower, PROT_READ | PROT_WRITE | PROT_EXEC) == -1) {
		// 	perror("mprotect");
		// 	// printf("mprotect failed: %x %x\n", lower, move_addr);
		// 	goto err_quit;
		// }
		if (directions[i] == 0) {
			printf("U");
			// move_up(mz);
			*move_addr = (void *) move_up_addr;
		} else if (directions[i] == 1) {
			printf("D");
			// move_down(mz);
			*move_addr = (void *) move_down_addr;
		} else if (directions[i] == 2) {
			printf("L");
			// move_left(mz);
			*move_addr = (void *) move_left_addr;
		} else if (directions[i] == 3) {
			printf("R");
			// move_right(mz);
			*move_addr = (void *) move_right_addr;
		}
		// if (mprotect(lower, (char*)upper - (char*)lower, PROT_READ | PROT_EXEC) == -1) {
		// 	perror("mprotect");
		// 	goto err_quit;
		// }
	}
	if (mprotect(got_min, (char*)got_max - (char*)got_min, PROT_READ | PROT_EXEC) == -1) {
		perror("mprotect");
		goto err_quit;
	}
	return mz;
err_quit:
	if(mz) free(mz);
	if(fp) fclose(fp);
	return NULL;
}
*/

void
maze_free(maze_t *mz) {
	free(mz);
}

static int _dirx[] = { 0, 0, -1, 1 };
static int _diry[] = { -1, 1, 0, 0 };

static void
move_dir(maze_t *mz, int d) {
	int nx = mz->cx + _dirx[d];
	int ny = mz->cy + _diry[d];
	//
	if(mz->blk[ny][nx] != 0) return;
	mz->cx = nx;
	mz->cy = ny;
	// reach the END
	if(mz->cx == mz->ex && mz->cy == mz->ey) {
		printf("\nBingo!\n");
		exit(0);
	}
}

void move_up(maze_t *mz)     { move_dir(mz, 0); }
void move_down(maze_t *mz)   { move_dir(mz, 1); }
void move_left(maze_t *mz)   { move_dir(mz, 2); }
void move_right(maze_t *mz)  { move_dir(mz, 3); }
void move_random(maze_t *mz) { move_dir(mz, rand() % 4); }

#define MOVE(n)	void move_##n(maze_t *mz) { move_random(mz); }
#include "moves.c"
#undef MOVE

